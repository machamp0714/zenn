---
title: "Rails on ECS with FluentBitな構成で快適なログ分析環境を構築する"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Rails", "AWS"]
published: false
---
# この記事は？？

Rails on ECSな構成で運用する時、通常Dokcerのログドライバに`awslogs`を指定してログを
CloudWatch Logsに配信すると思います。ただしこのやり方には問題があり、**複数行のログが
ログストリームに１行ずつログイベントして蓄積されていくことです。**

例えばRailsの開発をしているときは以下の様なログを確認しながら開発を進めていくと思いますが、これらが1行ずつログストリームに配信されます。これでは不具合が発生した時に発生した場所や不具合の内容を特定するのが困難になります。
```
Started GET "/" for 172.21.0.1 at 2021-12-31 12:30:46 +0000
Cannot render console from 172.21.0.1! Allowed networks: 127.0.0.0/127.255.255.255, ::1
Processing by WelcomeController#index as HTML
  Rendering layout layouts/application.html.slim
  Rendering welcome/index.html.slim within layouts/application
  Rendered application/_flash.html.slim (Duration: 0.2ms | Allocations: 28)
  Rendered layout layouts/application.html.slim (Duration: 96.8ms | Allocations: 10334)
Completed 200 OK in 144ms (Views: 90.0ms | ActiveRecord: 13.0ms | Allocations: 16439)
```
これはログをJSON形式で配信することで解消出来ます。

またCloudWatchにはアプリケーションのログ以外にヘルスチェックのログも配信されます。
ただヘルスチェックのログはチェック間隔にもよりますが、かなりの量になると思います。
ログを閲覧する際にヘルスチェックのログは不要だと思うのでFluent Bitでログルーティングを
実施し別のログストリームに配信する方法を紹介します。

# この記事のゴール

- RailsのログをJSON形式に構造化して、CloudWatch Logsに配信する
- Fluent Bitでログルーティングの仕組みを構築する

# ログをJSON形式に変換する

ログをJSON形式に変形するために[lograge](https://github.com/roidrage/lograge)というライブラリを使用します。

```ruby
gem 'lograge'
```

## logrageを導入

まず、logrageをインストールします。

次にlogrageを有効化します。
`environments`配下の環境ごとのファイルに記述しても良いのですが、`initializers`配下に`lograge.rb`を作成してそこにlogrageの設定を記述することにします。完成形はこちらになります。

```ruby
# frozen_string_literal: true

Rails.application.configure do
  config.lograge.enabled = true

  config.lograge.custom_payload do |controller|
    request = controller.request
    current_user = controller.try(:current_user)
    log = {
      request_id: request.request_id,
      remote_ip:  request.remote_ip,
      host:       request.host,
      url:        request.original_url,
      user_agent: request.user_agent
    }
    log = log.merge(current_user: current_user) if current_user
    log
  end
end
```

`controller`メソッドにアクセスしてお馴染みの`current_user`や`request`オブジェクトを取得し
それらをログに含ませることも可能です。この部分は要件によって変わってくると思うので、
ご自由にカスタマイズしてください。ただし`user_agent`に関しては後述するヘルスチェックのログルーティングのために必須となります。

ここまで完了したら一度開発環境でログがどの様に変更されたか確認してみましょう。logrageのformatterはデフォルトで[Lograge::Formatters::KeyValue]([https://github.com/roidrage/lograge/blob/master/lib/lograge/formatters/key_value.rb](https://github.com/roidrage/lograge/blob/master/lib/lograge/formatters/key_value.rb))が使われているみたいなので、

```
method=GET path=/ format=html controller=WelcomeController action=index status=200 duration=13532.57 request_id=e053318a-e42c-4287-9376-0f45578afdd3 remote_ip=172.21.0.1 host=localhost url=http://localhost:3000/ user_agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36
```

こんな感じになるかと思います。`request_id`や`user_agent`など新たに追加した項目が確認出来ますが、まだJSON形式にはなっていませんね。次はFormatterを自作してJSON形式でログが配信されることを目指します。

## logrageのFormatterを実装する

```bash
$ mkdir app/lib/lograge/formatters/fluent_bit_json.rb
```

```ruby
# frozen_string_literal: true

module Lograge
  module Formatters
    class FluentBitJson
      def call(payload)
        current_user = payload[:current_user]
        status = payload[:status]

        log = {
          level:             level(status),
          status:            status,
          method:            payload[:method],
          path:              payload[:path],
          format:            payload[:format],
          controller:        "#{payload[:controller]}\##{payload[:action]}",
          duration:          payload[:duration],
          request_id:        payload[:request_id],
          remote_ip:         payload[:remote_ip],
          host:              payload[:host],
          url:               payload[:url],
          user_agent:        payload[:user_agent]
        }
        log = log.merge("user_id": current_user.id) if current_user

        log.to_json
      end
    end
  end
end

def level(status)
  case status
  when 100..400 then 'INFO'
  when 400...500 then 'WARNING'
  else 'ERROR'
  end
end
```

Formatterには`payload`を引数にとる`call`メソッドを実装していきます。内容は要件次第です
が、一先ず最低限必要な項目を追加しておきました。

```ruby
# frozen_string_literal: true

Rails.application.configure do
  config.lograge.enabled = true
  # 略
  config.lograge.formatter = Lograge::Formatters::FluentBitJson.new
end

```

自作したFormatterを指定して再度配信されるログを確認します。

```json
{
  "level": "INFO",
  "status": 200,
  "method": "GET",
  "path": "/",
  "format": "html",
  "controller": "WelcomeController#index",
  "duration": 2816.18,
  "request_id": "05a486ff-7d22-47c5-8e93-ca356b2a629a",
  "remote_ip": "172.21.0.1",
  "host": "localhost",
  "url": "http://localhost:3000/",
  "user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36",
}
```
この様にJSON形式で配信されていればOKです。

これでリクエストに関してはログを構造化することが出来たのですが、`Rails.logger`を使ってもJSON形式で出力されません。次はこの問題を解消していきます。

## Rails.loggerのFormatterを実装する

今度は `Rails.logger` のFormatterを実装することになるのですが、その前にロギングにおける
タグについて理解する必要があります。

```ruby
Rails.logger.tagged('hoge') { Rails.logger.info('piyo') }
```

を実行すると、

```ruby
[hoge] piyo
```

といったようにタグを付与することが出来ます。これは[こちら]([https://github.com/rails/rails/blob/main/activesupport/lib/active_support/tagged_logging.rb#L32)を読むと分かります。

`production.rb` ではデフォルトで

```ruby
config.log_tags = %i[request_id]
```

となっているので、`[05a486ff-7d22-47c5-8e93-ca356b2a629a] JSON形式のログ`という形式で
配信されることになります。

そうなんです。せっかくlogrageでJSON形式に変換しても文字列に変換されてしまうんです。
このタグが付与される挙動を頭に入れつつFormatterを実装していきます。

```ruby
# frozen_string_literal: true

module Logging
  module Formatters
    class FluentBitJson < ::Logger::Formatter
      def call(severity, _timestamp, _progname, message)
        log = {
          level: severity
        }

        if (tags = current_tags).present?
          # tagをjsonの中に追加して、messageからは削除する
          message = message.split("[#{tags.last}] ").last
          log[:tags] = tags
        end

        JSON.extend JSONExtension
        parsed = JSON.custom_parse(message, symbolize_names: true)

        log = if parsed.is_a?(Hash)
                log.merge(parsed)
              else
                log.merge(message: parsed)
              end
        "#{log.to_json}\n"
      end

      module JSONExtension
        def custom_parse(message, **args)
          JSON.parse(message, args)
        rescue JSON::ParserError
          message
        end
      end
    end
  end
end
```

logrageのFormatterを実装した時同様、`call`メソッドを実装していきます。ログの中身は要件次第なのでここでは言及しませんが、ポイントとしては`tags_text`の部分をJSON構造の中に追加して、`message`から`tags_text`の部分を削除している部分です。

またlogrrageから渡ってきた`message`はあまりjsonのネストを深くしたくないので`merge`して

```ruby
Rails.logger.info('hoge')
```

といった文字列などが渡ってきた時は `message` という項目を追加しています。

ここまで実装出来たら、

```ruby
Rails.logger.tagged('hoge') { Rails.logger.info('piyo') }
```

とconsoleで動作検証してみましょう。JSONで出力されればOKです。
次は、ログの配信先を内容によって振り分ける方法を解説していきます。

# FireLensとFluent Bitでログルーティングを実現する

ログルーティングを実現するためにFireLensとFluent Bitを利用します。各々の詳しい解説は公式に委ねて、ここでは全体像とFireLensとFluent Bitの役割についてまず解説したいと思います。

## ログルーティングの流れ

まず手順ですが以下の様になります。

1. タスク定義にFireLensを追加
2. Fluent Bitの設定ファイルを記述
3. Dockerイメージを作成
4. ECRにデプロイ
5. タスクを再起動

手順から分かる通り、FireLensを使うメリットは複雑な設定は全てAWSに任せて、**私たち開発者はFluent Bitの設定ファイルを作成するだけ**でログルーティングを実装出来ることです。

## FireLensは何をやっているの？？

Railsコンテナから出力された標準出力ログはUnixソケットを介してFireLensコンテナに送信され、FireLensコンテナはFluent Bitの設定ファイルを生成します。

(生成されるファイルは後述します）

### Fluent Bitは何をやっているの？？

![Screen Shot 2021-12-31 at 10.28.42.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e654d274-98bf-4873-ae6d-0f7d36dff2fc/Screen_Shot_2021-12-31_at_10.28.42.png)

公式から拝借したこの図を見るのが一番分かりやすいのですが、Fluent Bitは**常にこの順番でログを加工して設定したアウトプット先にログを配信します。**私たちはこの各セクションの設定をファイルに記述していく事になります。

## タスク定義にFireLensを追加する

前提として `ecs-cli` を採用したので今回は `docker-compose.yml` と `ecs-params.yml` を修正していきます。タスク定義をjsonで記述している場合は(公式ドキュメント)[[https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/firelens-taskdef.html](https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/firelens-taskdef.html)]を見てください。

```yaml
logging:
	driver: awsfirelens
```

まずRailsコンテナのログドライバを `awsfirelens` に変更します。 `awsfirelens` というログドライバは存在しないのですが、これはあくまでタスク定義用のシンタックスシュガーで実際はFluentedまたはFluent Bitのプライグインに変換されています。

次にFireLensをタスク定義に追加します。以下の様に記述します。

```yaml
log_router:
	image: 5924384318712.dkr.ecr.ap-northeast-1.amazonaws.com/fluent-bit-ecr:latest
  logging:
    driver: awslogs
    options:
      awslogs-group: production-log-group
      awslogs-region: ap-northeast-1
      awslogs-stream-prefix: firelens
```

次に `ecs-params.yml` に `log-router` を追加します。

```yaml
log_router:
	firelens_configuration:
	  type: fluentbit
    options:
	    config-file-type: file
      config-file-value: /fluent-bit/etc/extra.conf
```

`config-file-value` に指定している `extra.conf` は後で作成します。

ECSエージェントがFireLensコンテナを起動すると、Fluent Bitの設定ファイルを生成するのですが、

中身はこの様になっています。

```
[INPUT]
    Name forward
    unix_path /var/run/fluent.sock

[INPUT]
    Name forward
    Listen 0.0.0.0
    Port 24224

[INPUT]
    Name tcp
    Tag firelens-healthcheck
    Listen 127.0.0.1
    Port 8877

[FILTER]
    Name record_modifier
    Match *
    Record ec2_instance_id i-058c27c5922eb1f0a
    Record ecs_cluster ecs-cluster
    Record ecs_task_arn arn:aws:ecs:ap-northeast-1:5924384318712:task/ecs-cluster/523734f169ca4aa8b1a83b531055d9f1
    Record ecs_task_definition ecs-service:100

@INCLUDE /fluent-bit/etc/extra.conf

[OUTPUT]
    Name null
    Match firelens-healthcheck
```

`config-file-value` を指定すると自作した設定ファイルが `@INCLUDE` ディレクティブでインポートされます。

## extra.confを作成する

ここからはFluent Bitの設定ファイルを作成していきます。まず完成版からお見せします。

```yaml
[SERVICE]
    Parsers_File /fluent-bit/etc/parsers.conf

[FILTER]
    Name         parser
    Match        app-firelens-*
    Key_Name     log
    Parser       rails
    Preserve_Key false
    Reserve_Data true

[FILTER]
    Name rewrite_tag
    Match app-firelens-*
    Rule $user_agent ^(ELB-HealthChecker/2.0)$ Helath_Check false

[OUTPUT]
    Name              cloudwatch
    Match             Helath_Check
    region            ap-northeast-1
    log_group_name    jsaas-production-logs
    log_stream_prefix firelens/

[OUTPUT]
    Name              cloudwatch
    Match             app-firelens-*
    region            ap-northeast-1
    log_group_name    production-log-group
    log_stream_prefix firelens/
```

上から順番に解説していきます。

### SERVICEセクション

このセクションではグローバルなプロパティを定義することが出来ます。

ここで定義している `Parsers_File` にはFILTERセクションで使うパーサーファイルのパスを指定します。

### FILTERセクション

このセクションではログに新しいフィールドを追加したり、ルーティングに使うタグを追加したりすることが出来ます。 プロパティは利用するプラグインによって異なりますが、共通のプロパティも存在します。

[filter](https://www.notion.so/43775d4a76a94456a52f2d346e340a06)

**parserについて**

Formatterを実装してRailsのログをJSON形式で出力出来るように改修しましたが、実際には

```
{"log":"{\"status\": \"up and running\"}\r\n","stream":"stdout","time":"2018-03-09T01:01:44.851160855Z"}
```

この様なJSON文字列が流れてきます。これでは各プロパティにアクセスすることが出来ないのでparserを使ってJSONに変換する必要があります。

parserを利用するにはまずパーサーファイルを作成します。

```yaml
[PARSER]
    Name        rails
    Format      json
    # Command       |  Decoder  | Field | Optional Action   |
    # ==============|===========|=======|===================|
    Decode_Field_AS    escaped    log
```

`Name` は `extra.conf` で参照するのに使います。 `Format` にはJSON文字列を元の状態に戻したいので

`json` を指定してください。次にデコーダーを定義するのですが、2種類指定することが出来て今回は

`Decode_Field_AS` を指定しました。

[parser](https://www.notion.so/b43ebe6aad5746f3b1198edefc3967c4)

次に `parser` プラグイン固有のプロパティを見ていきます。

[parser](https://www.notion.so/a39806a958964feaa85387b5a34cd18b)

**rewrite_tagについて**

`rewrite_tag` を使うと新しいタグを付与してログレコードを再発行出来ます。再発行した際元のログを破棄するかどうか選択することも出来ます。

`Rule` プロパティでどのようにタグを付与するかの条件を定義することが出来、構成は

```yaml
KEY REGEX NEW_TAG KEEP
```

となります。

`KEY` にログのフィールドを記述します。例えば今回のケースですとログは

```json
{
  "level": "INFO",
  "status": 200,
  "method": "GET",
  "path": "/",
  "format": "html",
  "controller": "WelcomeController#index",
  "duration": 2816.18,
  "request_id": "05a486ff-7d22-47c5-8e93-ca356b2a629a",
  "remote_ip": "172.21.0.1",
  "host": "localhost",
  "url": "http://localhost:3000/",
  "user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36",
}
```

という構成ですので、 `user_agent` を指定する場合 `$user_agent` と書けます。

もし、ネストしたフィールドを指定したい場合は、 `$hoge['piyo']` と書くことが出来ます。

`REGEX` にはマッチングさせたいパターンを記述し、 `NEW_TAG` には新しく付与したいタグを記述します。そして `KEEP` には古いタグを持つ元のログを保持するかどうかをboolean値で指定します。

今回はヘルスチェックのログに `Health_Check` というタグを付与したいので、 `Rule` プロパティは

```json
Rule $user_agent ^(ELB-HealthChecker/2.0)$ Helath_Check false
```

と記述しました。

以上でFILTERセクションの解説は終わりですが、他にもたくさんのプラグインがあるので(公式のドキュメント)[[https://docs.fluentbit.io/manual/pipeline/filters](https://docs.fluentbit.io/manual/pipeline/filters)]もチェックしてみてください。

### OUTPUTセクション

このセクションではログの配信先を定義します。指定できる配信先はCloudWatch LogsやAmazon Kinesis Data StreamsからSlackまでかなり種類が豊富です。

今回はCloudWatch Logsに配信したいので、 `Name` には `cloudwatch` を指定しました。

`Match` にはログに付与されたタグと照合するパターンを記述するのですが、

| tag | value |
| --- | --- |
| Match | app-firelens-* |
| Match | Health_Check |

とOUTPUTセクションを複数定義します。仮に `log_stream_prefix` に `firelens` を指定した場合、

配信先のログストリームはそれぞれ [`firelens/app-firelens-6ef6872b0d3f44f1ab47a3332caecbb`](https://ap-northeast-1.console.aws.amazon.com/cloudwatch/home?region=ap-northeast-1#logsV2:log-groups/log-group/jsaas-dev-logs/log-events/firelens$252Fapp-firelens-6ef6872b0d3f44f1ab47a3332caecbba)

`firelens/Health_Check` となります。この様にFluent Bitではタグに応じて複数のOUTPUTセクションを定義することでログルーティングを実現することが出来ます。